
The sidebar’s “Recent Contracts” list must persist for each user
(across sessions and devices) and stay in sync in real-time.

STACK ASSUMPTIONS
• Node + Express backend (same repo)
• PostgreSQL via Prisma  OR  flat-file JSON in /storage
• React 18, TypeScript, React-Query on the front-end
────────────────────────────────────────
1.  DATA MODEL  (choose one)

A.  Postgres / Prisma
---------------------
model RecentContract {
  userId        String   @id @map("user_id")
  contractId    String   @id @map("contract_id")
  filename      String
  uploadedAt    DateTime
  lastViewedAt  DateTime
  riskScore     Int?      // optional, if analyser writes one
}

B.  Flat-file (quick start)
---------------------------
Path: /storage/{userId}/recent.json  
Shape:
[
  {
    "contractId": "abc123",
    "filename":   "Nymcard_MSA_Final.docx",
    "uploadedAt": "2025-07-21T11:45:22Z",
    "lastViewedAt": "2025-07-21T11:46:05Z",
    "riskScore": 8
  },
  …
]

────────────────────────────────────────
2.  BACKEND ROUTES   (server/routes/recent.ts)
────────────────────────────────────────
POST   /api/recent/touch
       body: { contractId, filename, riskScore? }
       → upsert row / JSON entry
       → set uploadedAt only if new
       → bump lastViewedAt = now
       → respond 204

GET    /api/recent?limit=15
       → return array sorted by lastViewedAt DESC

DELETE /api/recent/:contractId
       → delete row / entry

(If you already store contracts in a collection, you can simply add the
timestamps to that doc and query ORDER BY lastViewedAt.)

────────────────────────────────────────
3.  FRONT-END HOOK   (src/hooks/useRecentContracts.ts)
────────────────────────────────────────
import { useQuery, useMutation, queryClient } from "@tanstack/react-query";

export function useRecentContracts(limit = 15) {
  const { data = [], isLoading } = useQuery({
    queryKey: ["recent", limit],
    queryFn: () => fetch(`/api/recent?limit=${limit}`).then(r => r.json())
  });

  const touch = useMutation({
    mutationFn: (body: { contractId:string; filename:string; riskScore?:number }) =>
      fetch("/api/recent/touch", {
        method: "POST",
        headers: { "Content-Type":"application/json" },
        body: JSON.stringify(body)
      }),
    onSuccess: () => queryClient.invalidateQueries(["recent"])
  });

  return { recent: data, isLoading, touch };
}

────────────────────────────────────────
4.  SIDEBAR COMPONENT   (update)
────────────────────────────────────────
const { recent, isLoading, touch } = useRecentContracts();

function handleOpenChat(c) {
  openChat(c.contractId);
  touch.mutate({ contractId: c.contractId, filename: c.filename });
}

return (
  <div className="px-2">
    <h3 className="text-xs font-semibold text-[#0C2836]/60 mb-1">
      RECENT CONTRACTS
    </h3>

    {isLoading && <Spinner size="sm" />}

    {recent.map(c => (
      <SidebarLink
        key={c.contractId}
        label={c.filename}
        badge={riskBadge(c.riskScore)}   // optional
        onClick={() => handleOpenChat(c)}
      />
    ))}
  </div>
);

• Call `touch()` right after a successful upload as well:

```ts
upload(file).then(res => {
  touch.mutate({ contractId: res.id, filename: file.name, riskScore: res.risk });
});
──────────────────────────────────────── 5. REAL-TIME (optional but nice) ──────────────────────────────────────── • Add Server-Sent Events at /api/stream/updates emit: { type:"recent", userId } • In useRecentContracts(), open an EventSource and invalidate query on message → near-instant sidebar refresh across open tabs.
──────────────────────────────────────── 6. QA CHECKLIST ──────────────────────────────────────── ☑ Upload a doc → appears instantly in RECENT ☑ Refresh browser → list still there ☑ Log out / log in on another device → list loads ☑ Clicking a contract bumps it to top (lastViewedAt) ☑ Delete endpoint removes item, refresh hides it ☑ No race conditions when two tabs update simultaneously
──────────────────────────────────────── DELIVERABLES ─────────────
* server/routes/recent.ts
* server/db/recentContracts.[ts|prisma] (or JSON util)
* src/hooks/useRecentContracts.ts
* Sidebar component patch
* (Optional) server/routes/stream.ts + SSE hook
COMMENT “recent persistence done” once the list survives reloads. **/
Paste that task into your Replit Vibe-Coding agent, hit **Run**, and the agent will build the persistence layer, API routes, React hook, and UI patch so **Recent Contracts now sticks for the user’s entire lifecycle**.
