// utils/contractParser.js

export const parseContractAnalysis = (llmResponse, fileName, contractText) => {
  console.log('Parsing contract analysis...');
  
  // Extract contract type from filename or content
  const contractType = detectContractType(fileName, contractText, llmResponse);
  
  // Extract parties
  const parties = extractParties(contractText, llmResponse);
  
  // Extract terms
  const terms = extractContractTerms(llmResponse);
  
  // Extract execution status
  const isExecuted = detectExecutionStatus(contractText, llmResponse);
  
  // Extract language
  const language = detectLanguage(contractText);
  
  const parsedData = {
    contractType,
    internalParty: parties.internal || 'Your Company',
    counterparty: parties.counter || 'Unknown',
    governingLaw: terms.governingLaw || 'Not Specified',
    paymentTerms: terms.payment || 'Not Specified',
    breachNotice: terms.breach || 'Not Specified',
    terminationNotice: terms.termination || 'Not Specified',
    isExecuted,
    language,
    riskScore: llmResponse.riskScore || 0,
    findings: llmResponse.findings || []
  };
  
  console.log('Parsed contract data:', parsedData);
  return parsedData;
};

// Contract type detection
const detectContractType = (fileName, text, llmResponse) => {
  const lowerText = text.toLowerCase();
  const lowerFileName = fileName.toLowerCase();
  
  if (lowerText.includes('service agreement') || lowerFileName.includes('service')) {
    return 'Service Agreement';
  } else if (lowerText.includes('non-disclosure') || lowerText.includes('nda')) {
    return 'NDA';
  } else if (lowerText.includes('employment contract')) {
    return 'Employment Contract';
  } else if (lowerText.includes('sales agreement')) {
    return 'Sales Agreement';
  }
  
  return 'Other';
};

// Extract parties from contract
const extractParties = (contractText, llmResponse) => {
  // Look for common patterns
  const partyPatterns = {
    between: /between\s+([^,]+)\s+(?:,|and)\s+([^,]+)/i,
    parties: /parties:\s*([^,]+)\s+and\s+([^,]+)/i,
    agreement: /agreement\s+between\s+([^,]+)\s+and\s+([^,]+)/i
  };
  
  for (const pattern of Object.values(partyPatterns)) {
    const match = contractText.match(pattern);
    if (match) {
      return {
        internal: match[1].trim(),
        counter: match[2].trim()
      };
    }
  }
  
  // Fallback: try to extract from LLM findings
  return {
    internal: 'Your Company',
    counter: 'Counterparty'
  };
};

// Extract contract terms
const extractContractTerms = (llmResponse) => {
  const terms = {};
  
  // Look through findings for specific terms
  if (llmResponse.findings) {
    llmResponse.findings.forEach(finding => {
      if (finding.type === 'payment' || finding.description.toLowerCase().includes('payment')) {
        // Extract payment terms like "Net 30"
        const match = finding.description.match(/net\s*(\d+)/i);
        if (match) {
          terms.payment = `Net ${match[1]}`;
        }
      }
      
      if (finding.type === 'termination') {
        // Extract termination notice period
        const match = finding.description.match(/(\d+)\s*days?/i);
        if (match) {
          terms.termination = `${match[1]} days`;
        }
      }
      
      if (finding.description.toLowerCase().includes('governing law')) {
        // Extract governing law
        const match = finding.description.match(/laws?\s+of\s+([^,\\.]+)/i);
        if (match) {
          terms.governingLaw = match[1].trim();
        }
      }
    });
  }
  
  return terms;
};

// Detect if contract is executed
const detectExecutionStatus = (contractText, llmResponse) => {
  const executionIndicators = [
    'executed as of',
    'signed on',
    'effective date',
    '/s/',
    'signature'
  ];
  
  const lowerText = contractText.toLowerCase();
  return executionIndicators.some(indicator => lowerText.includes(indicator));
};

// Detect language
const detectLanguage = (contractText) => {
  // Simple Arabic detection
  const arabicPattern = /[\u0600-\u06FF]/;
  if (arabicPattern.test(contractText)) {
    return 'Arabic';
  }
  return 'English';
};